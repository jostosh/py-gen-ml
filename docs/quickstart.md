# 🚀 Quick Start Guide

## 🌟 Introduction

`py-gen-ml` leverages protobufs, a powerful structured data format, to define the schema for your configuration. Protobufs are language-neutral, platform-neutral, and extensible, making them ideal for serializing and deserializing data. The protobuf ecosystem allows for custom plugins to generate code for various serialization formats. `py-gen-ml` takes advantage of this flexibility to generate Pydantic models and JSON schemas, creating a robust and versatile configuration system.

!!! note
    While `py-gen-ml` currently doesn't fully utilize the language-neutral or platform-neutral features of protobuf, these capabilities are available for future expansion. If you're new to protobufs, you can learn more about them [here](https://developers.google.com/protocol-buffers).

## 📝 Defining Your Protobuf

To create a protobuf, you'll need to write a `.proto` file. This file contains the definition of the data structure you want to use in your configuration.

Here's a simple example of a protobuf definition:

```proto
// proto_intro.proto
syntax = "proto3";

package example;

import "py_gen_ml/extensions.proto";

message MLP {
    int64 num_layers = 1;
    int64 num_units = 2;
    string activation = 3;
}
```

## 🛠️ Generating Configuration Utilities

With your protobuf defined, you can now generate configuration utilities using this command:

```console
py-gen-ml proto_intro.proto
```

By default, the generated code will be written to `src/pgml_out`. To customize this and explore other options, check out the [py-gen-ml command](py-gen-ml-command.md) documentation. The command will generate four files:

- `proto_intro_base.py`
- `proto_intro_patch.py`
- `proto_intro_sweep.py`
- `proto_intro_cli_args.py`

Let's dive into the details of each file.

## 🧩 Generated Code

### 📊 `proto_intro_base.py`
```python { .generated-code }
--8<-- "docs/snippets/src/pgml_out/proto_intro_base.py"
```

This file defines a Pydantic model for your configuration that directly corresponds to the protobuf message. Use this file to load and validate configuration files written in YAML format.

For instance, the following YAML file will be validated according to the schema defined in `proto_intro_base.py`:

```yaml
# example.yaml
num_layers: 2
num_units: 100
activation: relu
```

### 🔧 `proto_intro_patch.py`

```python { .generated-code }
--8<-- "docs/snippets/src/pgml_out/proto_intro_patch.py"
```

This file defines a Pydantic model for your patch configuration. All fields are optional, allowing you to load and validate patch files written in YAML format.

For example, this YAML file will be validated according to the schema in `proto_intro_patch.py`:

```yaml
# example_patch.yaml
num_layers: 3
```

This is particularly useful for updating only a subset of the configuration. You can easily load a base configuration and apply patches using the `.from_yaml_files` method implemented for every descendant of `pgml.YamlBaseModel`:

```python
# example.py
from pgml_out.proto_intro_base import MLP
from pgml_out.proto_intro_patch import MLPPatch

config_with_patches = MLP.from_yaml_files(["example.yaml", "example_patch.yaml"])
```

### 🔍 `proto_intro_sweep.py`

```python { .generated-code }
--8<-- "docs/snippets/src/pgml_out/proto_intro_sweep.py"
```

This file defines a `pgml.Sweeper` for your configuration, enabling you to sweep over the values of your configuration. Define sweeps as additional YAML files that are applied as patches on top of the base configuration.

Here's an example YAML file that will be validated according to the schema in `proto_intro_sweep.py`:

```yaml
# example_sweep.yaml
num_layers:
    low: 1
    high: 5
```

To run a hyperparameter sweep, you can use the OptunaSampler:

```python
# example.py
from pgml_out.proto_intro_base import MLP
from pgml_out.proto_intro_sweep import MLPSweep

def train_model(config: MLP) -> float:
    """Train a model and return the accuracy"""

if __name__ == "__main__":
    config = MLP.from_yaml_file("example.yaml")
    sweep = MLPSweep.from_yaml_file("example_sweep.yaml")

    def objective(trial: optuna.Trial) -> float:
        sampler = pgml.OptunaSampler(trial=trial)
        patch = sampler.sample(sweep)
        accuracy = train_model(config.merge(patch))
        return accuracy

    study = optuna.create_study(direction="maximize")
    study.optimize(objective, n_trials=100)
```

### 💻 `proto_intro_cli_args.py`

```python
# proto_intro_cli_args.py
# Autogenerated code. DO NOT EDIT.
import py_gen_ml as pgml
import typing

import pydantic
import typer

from . import proto_intro_base as base


class MLPArgs(pgml.YamlBaseModel):
    """Multi-layer perceptron configuration"""

    num_layers: typing.Annotated[typing.Optional[int], typer.Option(help="Number of layers"), pydantic.Field(None)]
    """Number of layers"""

    num_units: typing.Annotated[typing.Optional[int], typer.Option(help="Number of units"), pydantic.Field(None)]
    """Number of units"""

    activation: typing.Annotated[typing.Optional[str], typer.Option(help="Activation function"), pydantic.Field(None)]
    """Activation function"""
```

This file defines a Pydantic model for your command line arguments. We've chosen to use [typer](https://typer.tiangolo.com/) to handle command line arguments, and we've added a convenience function to simplify the use of this class.

Here's how you can use it in your script:

```python
# example.py
from pgml_out.proto_intro_base import MLP
from pgml_out.proto_intro_cli_args import MLPArgs
import py_gen_ml as pgml
import typer

app = typer.Typer(pretty_exceptions_enable=False)

@pgml.pgml_cmd(app)
def main(other_arg: str = "other_arg", config_path: str = "example.yaml", cli_args: MLPArgs = typer.Option(...)) -> None:
    print(f"other_arg: {other_arg}")
    print(f"num_layers: {cli_args.num_layers}")
    print(f"num_units: {cli_args.num_units}")
    print(f"activation: {cli_args.activation}")

    config = MLP.from_yaml_file(config_path)
    config = config.apply_cli_args(cli_args)
    print(f"config: {config}")


if __name__ == "__main__":
    app()
```

Now you can run your script with command line arguments and configuration files:

```console
python example.py --help
```

This will display a helpful usage guide:

```
 Usage: example.py [OPTIONS]

╭─ Options ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ --other-arg                 TEXT                             [default: other_arg]                     │
│ --config-path               TEXT                             [default: example.yaml]                  │
│ --num-layers                INTEGER                          Number of layers [default: None]         │
│ --num-units                 INTEGER                          Number of units [default: None]          │
│ --activation                TEXT                             Activation function [default: None]      │
│ --install-completion        [bash|zsh|fish|powershell|pwsh]  Install completion for the specified     │
│                                                              shell.                                   │
│                                                              [default: None]                          │
│ --show-completion           [bash|zsh|fish|powershell|pwsh]  Show completion for the specified shell, │
│                                                              to copy it or customize the              │
│                                                              installation.                            │
│                                                              [default: None]                          │
│ --help                                                       Show this message and exit.              │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

You can set parameters via both command line arguments and configuration files:

```console
python example.py --num-layers 3
```

This will set the `num_layers` parameter to `3`, while other parameters will be set to the values in the configuration file. The script will output:

```
other_arg: other_arg
num_layers: 3
num_units: None
activation: None
config: num_layers=3 num_units=100 activation='relu'
```

Other arguments can be easily configured as well:

```console
python example.py --other-arg "other_arg_2"
```

Which will print:

```
other_arg: other_arg_2
num_layers: None
num_units: None
activation: None
config: num_layers=2 num_units=100 activation='relu'
```

With these tools at your disposal, you're now ready to create flexible and powerful configurations for your machine learning projects using `py-gen-ml`! If you're looking for a more complex example, check out the [CIFAR 10 example project](example_projects/cifar10.md).
